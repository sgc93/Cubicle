<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Three.js 3D Editor</title>
    <style>
        /* --- Blender-Inspired Global Styles --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: sans-serif; 
            background-color: #333; /* Dark background */
        }
        
        /* --- Main Layout: Editor Container --- */
        #editor-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* --- Sidebar (Properties Panel) --- */
        #sidebar {
            width: 300px; /* Fixed width for the panel */
            background: #2c2c2c;
            color: #ffffff;
            padding: 15px;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
            font-size: 13px;
        }
        
        /* --- Viewport (Three.js Canvas) --- */
        #container { 
            flex-grow: 1; /* Takes up all remaining space */
            position: relative;
        }

        /* --- UI Elements --- */
        #sidebar h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f77f00; /* Orange/Gold accent */
            text-transform: uppercase;
            font-size: 1.1em;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        
        #sidebar h4 {
            color: #aaa;
            margin: 15px 0 8px 0;
            font-size: 1em;
        }

        #sidebar button {
            display: block;
            width: 100%;
            margin-bottom: 6px;
            padding: 8px;
            border: 1px solid #444;
            background-color: #444;
            color: white;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.1s;
        }
        #sidebar button:hover {
            background-color: #555;
        }

        /* --- Property Rows --- */
        .property-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding: 3px 0;
        }
        .property-row label {
            width: 80px;
            font-weight: bold;
            color: #ccc;
        }
        .property-input {
            width: 100px;
            padding: 4px;
            border: 1px solid #444;
            background-color: #555;
            color: white;
            border-radius: 2px;
            text-align: right;
        }
        .property-input:disabled {
            background-color: #333;
            color: #777;
        }
        
        /* Persistence Buttons Styling */
        #scene-data-controls button {
            background-color: #1e88e5; /* Blue accent */
            border-color: #1e88e5;
        }
        #scene-data-controls button:hover {
            background-color: #42a5f5;
        }
        
        hr {
            border: none;
            border-top: 1px solid #444;
            margin: 10px 0;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="container"></div>

        <div id="sidebar">
            <h3>Object Editor</h3>

            <h4>Creation Tools</h4>
            <button onclick="addShape('box')">Add Box</button>
            <button onclick="addShape('sphere')">Add Sphere</button>
            <button onclick="addShape('cylinder')">Add Cylinder</button>

            <hr>

            <div id="selection-info">
                <h4>Selected Object Properties</h4>
                <div class="property-row">
                    <label>Type:</label> <span id="object-type" style="color:#f77f00; font-weight: bold;">None</span>
                </div>
                
                <hr>

                <h4>Position</h4>
                <div class="property-row">
                    <label>X:</label> <input type="number" id="pos-x" step="0.1" class="property-input" onchange="updateObjectProperty('position.x', this.value)">
                </div>
                <div class="property-row">
                    <label>Y:</label> <input type="number" id="pos-y" step="0.1" class="property-input" onchange="updateObjectProperty('position.y', this.value)">
                </div>
                <div class="property-row">
                    <label>Z:</label> <input type="number" id="pos-z" step="0.1" class="property-input" onchange="updateObjectProperty('position.z', this.value)">
                </div>

                <h4>Rotation (Degrees)</h4>
                <div class="property-row">
                    <label>X:</label> <input type="number" id="rot-x" step="5" class="property-input" onchange="updateObjectRotation('rotation.x', this.value)">
                </div>
                <div class="property-row">
                    <label>Y:</label> <input type="number" id="rot-y" step="5" class="property-input" onchange="updateObjectRotation('rotation.y', this.value)">
                </div>
                <div class="property-row">
                    <label>Z:</label> <input type="number" id="rot-z" step="5" class="property-input" onchange="updateObjectRotation('rotation.z', this.value)">
                </div>

                <h4>Scale</h4>
                <div class="property-row">
                    <label>X:</label> <input type="number" id="scale-x" step="0.1" class="property-input" onchange="updateObjectScale('scale.x', this.value)">
                </div>
                <div class="property-row">
                    <label>Y:</label> <input type="number" id="scale-y" step="0.1" class="property-input" onchange="updateObjectScale('scale.y', this.value)">
                </div>
                <div class="property-row">
                    <label>Z:</label> <input type="number" id="scale-z" step="0.1" class="property-input" onchange="updateObjectScale('scale.z', this.value)">
                </div>
                
                <hr>
                
                <h4>Base Dimensions (Read-Only)</h4>
                <div class="property-row">
                    <label>Dimension 1:</label> <span id="dim-1" style="color:#f77f00;"></span>
                </div>
                <div class="property-row">
                    <label>Dimension 2:</label> <span id="dim-2" style="color:#f77f00;"></span>
                </div>
                <div class="property-row">
                    <label>Dimension 3:</label> <span id="dim-3" style="color:#f77f00;"></span>
                </div>
            </div>

            <hr>

            <div id="scene-data-controls">
                <h4>Scene Persistence</h4>
                <button onclick="exportScene()">Export Scene (to Console/Clipboard)</button>
                <button onclick="promptImport()">Import Scene (Paste JSON)</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
        // --- Core Setup Variables ---
        let scene, camera, renderer, controls, raycaster, mouse;
        let selectableObjects = [];
        let selectedObject = null;
        const container = document.getElementById('container');
        let transformControls;

        // Initial material properties
        const BASE_COLOR = 0x5599ff;
        const HIGHLIGHT_COLOR = 0xff0000;
        const BASE_MATERIAL = new THREE.MeshPhongMaterial({ color: BASE_COLOR, specular: 0x111111, shininess: 30 });

        // Helper function for converting degrees to radians
        const degToRad = (degrees) => degrees * (Math.PI / 180);
        const radToDeg = (radians) => radians * (180 / Math.PI);

        // --- Initialization ---
        init();
        animate();

        function init() {
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e); // Darker background
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040));
            const light = new THREE.DirectionalLight(0xffffff, 1.0);
            light.position.set(20, 30, 10);
            scene.add(light);

            // OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 

            // Helpers
            scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x444444));
            scene.add(new THREE.AxesHelper(5));

            // Raycasting Setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // TransformControls setup
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value; // Disable orbit when dragging
                if (!event.value) { // Update sidebar when drag ends
                    updateSidebar();
                }
            });
            transformControls.setMode("translate"); // Start in translate mode
            scene.add(transformControls);
            
            // Allow keyboard shortcuts for TransformControls: T=Translate, R=Rotate, S=Scale
            window.addEventListener('keydown', function (event) {
                switch (event.key) {
                    case 't': transformControls.setMode("translate"); break;
                    case 'r': transformControls.setMode("rotate"); break;
                    case 's': transformControls.setMode("scale"); break;
                    case 'Delete': 
                    case 'Backspace':
                        if (selectedObject) deleteSelectedObject();
                        break;
                }
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onMouseClick, false);

            // Start scene
            addShape('box', new THREE.Vector3(2, 0.5, 2));
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Object Management ---

        function addShape(type, position) {
            // ... (Shape creation logic remains the same)
            let geometry;
            let mesh;
            let randomSize = Math.random() * 1.5 + 0.5;

            switch (type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(randomSize, randomSize, randomSize);
                    mesh = new THREE.Mesh(geometry, BASE_MATERIAL.clone());
                    mesh.userData.shapeType = 'Box';
                    mesh.userData.dimensions = { width: randomSize, height: randomSize, depth: randomSize };
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(randomSize / 2, 32, 32);
                    mesh = new THREE.Mesh(geometry, BASE_MATERIAL.clone());
                    mesh.userData.shapeType = 'Sphere';
                    mesh.userData.dimensions = { radius: randomSize / 2 };
                    break;
                case 'cylinder':
                    let radiusTop = randomSize / 2;
                    let radiusBottom = radiusTop * (Math.random() * 0.5 + 0.5);
                    let height = randomSize * 2;
                    geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 32);
                    mesh = new THREE.Mesh(geometry, BASE_MATERIAL.clone());
                    mesh.userData.shapeType = 'Cylinder';
                    mesh.userData.dimensions = { radiusTop: radiusTop, radiusBottom: radiusBottom, height: height };
                    break;
                default:
                    return;
            }

            // Set position (on grid based on geometry center)
            if (position) {
                mesh.position.copy(position);
            } else {
                mesh.position.x = (Math.random() - 0.5) * 10;
                mesh.position.y = mesh.userData.shapeType === 'Box' ? randomSize / 2 : 
                                  mesh.userData.shapeType === 'Sphere' ? randomSize / 2 : height / 2;
                mesh.position.z = (Math.random() - 0.5) * 10;
            }

            mesh.uuid = THREE.MathUtils.generateUUID();
            mesh.userData.id = mesh.uuid;
            mesh.name = `${mesh.userData.shapeType}_${mesh.uuid.substring(0, 4)}`;

            scene.add(mesh);
            selectableObjects.push(mesh);
            selectObject(mesh);
        }
        
        function deleteSelectedObject() {
            if (!selectedObject) return;
            
            // Remove from scene and selectable list
            scene.remove(selectedObject);
            selectableObjects = selectableObjects.filter(obj => obj.uuid !== selectedObject.uuid);
            
            // Dispose of resources
            selectedObject.geometry.dispose();
            selectedObject.material.dispose();
            
            // Deselect
            selectObject(null);
        }

        // --- Selection & Highlight ---

        function onMouseClick(event) {
            if (transformControls.dragging) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
            mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(selectableObjects, false);

            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            } else {
                selectObject(null);
            }
        }

        function selectObject(object) {
            if (selectedObject && selectedObject !== object) {
                selectedObject.material.color.set(BASE_COLOR);
                transformControls.detach();
            }

            selectedObject = object;

            if (selectedObject) {
                selectedObject.material.color.set(HIGHLIGHT_COLOR);
                transformControls.attach(selectedObject);
            }

            updateSidebar();
        }

        // --- Sidebar/Property Display and Manipulation ---

        // Position handler (same as before)
        function updateObjectProperty(propertyPath, value) {
            if (!selectedObject) return;
            const numericValue = parseFloat(value);
            if (isNaN(numericValue)) return;
            const parts = propertyPath.split('.');
            if (parts.length === 2) {
                if (selectedObject[parts[0]] && selectedObject[parts[0]][parts[1]] !== undefined) {
                    selectedObject[parts[0]][parts[1]] = numericValue;
                    updateSidebar();
                }
            }
        }
        
        // Rotation handler (NEW)
        function updateObjectRotation(propertyPath, value) {
            if (!selectedObject) return;
            const numericValue = parseFloat(value);
            if (isNaN(numericValue)) return;
            
            const parts = propertyPath.split('.');
            if (parts.length === 2 && parts[0] === 'rotation') {
                // Three.js rotation is in Radians, but user input is in Degrees
                const radians = degToRad(numericValue);
                selectedObject.rotation[parts[1]] = radians;
                updateSidebar(); // Refresh the sidebar
            }
        }

        // Scale handler (same as before)
        function updateObjectScale(propertyPath, value) {
            if (!selectedObject) return;
            const numericValue = parseFloat(value);
            if (isNaN(numericValue) || numericValue <= 0) {
                alert("Scale value must be a positive number.");
                updateSidebar();
                return;
            }
            const parts = propertyPath.split('.');
            if (parts[0] === 'scale' && selectedObject.scale[parts[1]] !== undefined) {
                selectedObject.scale[parts[1]] = numericValue;
                updateSidebar();
            }
        }

        /**
         * Updates the sidebar with all properties.
         */
        function updateSidebar() {
            // Get all property input elements
            const inputs = {
                type: document.getElementById('object-type'),
                posX: document.getElementById('pos-x'),
                posY: document.getElementById('pos-y'),
                posZ: document.getElementById('pos-z'),
                rotX: document.getElementById('rot-x'),
                rotY: document.getElementById('rot-y'),
                rotZ: document.getElementById('rot-z'),
                scaleX: document.getElementById('scale-x'),
                scaleY: document.getElementById('scale-y'),
                scaleZ: document.getElementById('scale-z'),
                dim1: document.getElementById('dim-1'),
                dim2: document.getElementById('dim-2'),
                dim3: document.getElementById('dim-3'),
            };

            if (selectedObject) {
                // Enable inputs
                Object.values(inputs).filter(el => el && el.tagName === 'INPUT').forEach(el => el.disabled = false);

                // Type
                inputs.type.textContent = selectedObject.userData.shapeType;

                // Position
                const pos = selectedObject.position;
                inputs.posX.value = pos.x.toFixed(2);
                inputs.posY.value = pos.y.toFixed(2);
                inputs.posZ.value = pos.z.toFixed(2);
                
                // Rotation (Convert Radians to Degrees)
                const rot = selectedObject.rotation;
                inputs.rotX.value = radToDeg(rot.x).toFixed(1);
                inputs.rotY.value = radToDeg(rot.y).toFixed(1);
                inputs.rotZ.value = radToDeg(rot.z).toFixed(1);

                // Scale
                const scale = selectedObject.scale;
                inputs.scaleX.value = scale.x.toFixed(2);
                inputs.scaleY.value = scale.y.toFixed(2);
                inputs.scaleZ.value = scale.z.toFixed(2);

                // Dimensions (Read-Only)
                const dims = selectedObject.userData.dimensions;
                // Simplified dimension display logic
                inputs.dim1.textContent = dims.width ? `W: ${dims.width.toFixed(2)}` : dims.radius ? `R: ${dims.radius.toFixed(2)}` : `R Top: ${dims.radiusTop.toFixed(2)}`;
                inputs.dim2.textContent = dims.height ? `H: ${dims.height.toFixed(2)}` : dims.radiusBottom ? `R Bot: ${dims.radiusBottom.toFixed(2)}` : '—';
                inputs.dim3.textContent = dims.depth ? `D: ${dims.depth.toFixed(2)}` : dims.height ? `H: ${dims.height.toFixed(2)}` : '—';

            } else {
                // Deselect state
                inputs.type.textContent = 'None';
                // Reset all input values
                Object.values(inputs).filter(el => el && el.tagName === 'INPUT').forEach(el => {
                    el.value = '—';
                    el.disabled = true;
                });
                inputs.dim1.textContent = inputs.dim2.textContent = inputs.dim3.textContent = '—';
            }
        }

        // --- Scene Persistence (JSON) ---

        function exportScene() {
            const objectsData = [];
            selectableObjects.forEach(object => {
                objectsData.push({
                    uuid: object.uuid,
                    type: object.userData.shapeType,
                    position: object.position.toArray(),
                    rotation: object.rotation.toArray(), // Rotation is now included
                    scale: object.scale.toArray(),
                    dimensions: object.userData.dimensions,
                });
            });

            const sceneData = {
                version: '1.1', // Version update due to new features
                objects: objectsData,
                metadata: {
                    camera: {
                        position: camera.position.toArray(),
                        target: controls.target.toArray()
                    }
                }
            };

            const jsonOutput = JSON.stringify(sceneData, null, 2);
            console.log("--- Scene JSON Export (v1.1) ---");
            console.log(jsonOutput);
            alert("Scene JSON data has been logged to the console (F12) and copied to your clipboard.");
            navigator.clipboard.writeText(jsonOutput);
        }

        function promptImport() {
            const jsonInput = prompt("Paste the Scene JSON data here to import (Supports v1.0 and v1.1):", "");
            if (jsonInput) {
                try {
                    importScene(jsonInput);
                } catch (e) {
                    alert("Error importing scene: Invalid JSON format or data structure.");
                    console.error("Import Error:", e);
                }
            }
        }

        function importScene(jsonString) {
            const sceneData = JSON.parse(jsonString);

            if (!['1.0', '1.1'].includes(sceneData.version)) {
                alert("Unsupported scene version.");
                return;
            }

            // 1. Clear existing scene objects 
            selectableObjects.forEach(object => {
                scene.remove(object);
                object.geometry.dispose();
                object.material.dispose(); 
            });
            selectableObjects = [];
            selectObject(null); 

            // 2. Recreate objects
            sceneData.objects.forEach(data => {
                let geometry;
                let mesh;
                const material = BASE_MATERIAL.clone();

                switch (data.type) {
                    case 'Box':
                        const boxDims = data.dimensions;
                        geometry = new THREE.BoxGeometry(boxDims.width, boxDims.height, boxDims.depth);
                        break;
                    case 'Sphere':
                        const sphereDims = data.dimensions;
                        geometry = new THREE.SphereGeometry(sphereDims.radius, 32, 32);
                        break;
                    case 'Cylinder':
                        const cylinderDims = data.dimensions;
                        geometry = new THREE.CylinderGeometry(cylinderDims.radiusTop, cylinderDims.radiusBottom, cylinderDims.height, 32);
                        break;
                    default:
                        console.warn(`Unknown object type during import: ${data.type}`);
                        return;
                }

                mesh = new THREE.Mesh(geometry, material);

                // Restore properties
                mesh.position.fromArray(data.position);
                // Check if rotation data exists (for v1.0 compatibility)
                if (data.rotation) {
                    mesh.rotation.fromArray(data.rotation);
                }
                mesh.scale.fromArray(data.scale);
                mesh.uuid = data.uuid;
                mesh.userData.shapeType = data.type;
                mesh.userData.dimensions = data.dimensions;
                mesh.name = `${data.type}_${mesh.uuid.substring(0, 4)}`;

                scene.add(mesh);
                selectableObjects.push(mesh);
            });

            // 3. Restore camera/controls
            if (sceneData.metadata && sceneData.metadata.camera) {
                camera.position.fromArray(sceneData.metadata.camera.position);
                controls.target.fromArray(sceneData.metadata.camera.target);
                controls.update();
            }

            alert(`Scene successfully imported with ${sceneData.objects.length} objects!`);
        }
    </script>
</body>
</html>