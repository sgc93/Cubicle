<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Three.js 3D Editor</title>
    <style>
        /* --- Blender-Inspired Global Styles --- */
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Inter', sans-serif; 
            background-color: #333; /* Dark background */
        }
        
        /* --- Main Layout: Editor Container --- */
        #editor-container {
            display: flex;
            width: 100vw;
            height: 100vh;
        }

        /* --- Sidebar (Properties Panel) --- */
        #sidebar {
            width: 300px; /* Fixed width for the panel */
            background: #2c2c2c;
            color: #ffffff;
            padding: 15px;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0, 0, 0, 0.5);
            font-size: 13px;
        }
        
        /* --- Viewport (Three.js Canvas) --- */
        #container { 
            flex-grow: 1; /* Takes up all remaining space */
            position: relative;
        }

        /* --- UI Elements --- */
        #sidebar h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #f77f00; /* Orange/Gold accent */
            text-transform: uppercase;
            font-size: 1.1em;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        
        #sidebar h4 {
            color: #aaa;
            margin: 15px 0 8px 0;
            font-size: 1em;
        }

        #sidebar button {
            display: inline-block; /* Changed to inline-block for transform controls */
            width: 100%;
            margin-bottom: 6px;
            padding: 8px;
            border: 1px solid #444;
            background-color: #444;
            color: white;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.1s, box-shadow 0.1s;
        }
        #sidebar button:hover {
            background-color: #555;
            box-shadow: 0 0 5px rgba(247, 127, 0, 0.5);
        }
        
        #sidebar button.active {
            background-color: #f77f00;
            border-color: #f77f00;
            font-weight: bold;
        }

        /* --- Property Rows --- */
        .property-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
            padding: 3px 0;
        }
        .property-row label {
            width: 80px;
            font-weight: bold;
            color: #ccc;
        }
        .property-input {
            width: 100px;
            padding: 4px;
            border: 1px solid #444;
            background-color: #555;
            color: white;
            border-radius: 2px;
            text-align: right;
        }
        .property-input:disabled {
            background-color: #333;
            color: #777;
        }
        
        /* Special inputs */
        input[type="color"] {
            width: 100px;
            height: 25px;
            padding: 0;
            border: none;
            background: #555;
            cursor: pointer;
            border-radius: 2px;
        }

        /* Persistence Buttons Styling */
        #scene-data-controls button {
            background-color: #1e88e5; /* Blue accent */
            border-color: #1e88e5;
            width: 100%; /* Reset to full width for export/import */
        }
        #scene-data-controls button:hover {
            background-color: #42a5f5;
        }
        
        /* Transform Mode Button Group */
        #transform-modes button {
            width: 32%;
            margin-right: 2%;
        }
        #transform-modes button:last-child {
            margin-right: 0;
        }
        
        /* Utility */
        hr {
            border: none;
            border-top: 1px solid #444;
            margin: 10px 0;
        }

        /* --- Custom Message Box --- */
        #message-box {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 20px;
            background-color: #4CAF50; /* Default: Success/Info */
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.5s, transform 0.5s;
            z-index: 1000;
            pointer-events: none; /* Allows clicks to pass through when hidden */
        }
        #message-box.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(0);
            pointer-events: auto;
        }
        #message-box.error {
            background-color: #F44336; /* Error */
        }
        
        /* --- Import Modal --- */
        #import-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }
        #import-modal.visible {
            display: flex;
        }
        #import-content {
            background: #2c2c2c;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            width: 90%;
            max-width: 500px;
        }
        #import-content textarea {
            width: 100%;
            height: 150px;
            margin: 10px 0;
            padding: 10px;
            background: #555;
            border: 1px solid #444;
            color: white;
            resize: none;
            border-radius: 4px;
        }
        #import-content button {
            margin-top: 10px;
            width: 49%;
            display: inline-block;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="container"></div>

        <div id="sidebar">
            <h3>Object Editor (Three.js)</h3>

            <h4>Creation Tools</h4>
            <button onclick="addShape('box')">Add Box</button>
            <button onclick="addShape('sphere')">Add Sphere</button>
            <button onclick="addShape('cylinder')">Add Cylinder</button>

            <hr>
            
            <div id="transform-modes">
                <h4>Transform Mode (T, R, S)</h4>
                <button id="mode-translate" class="active" onclick="setTransformMode('translate')">Move (T)</button>
                <button id="mode-rotate" onclick="setTransformMode('rotate')">Rotate (R)</button>
                <button id="mode-scale" onclick="setTransformMode('scale')">Scale (S)</button>
            </div>
            
            <hr>

            <div id="selection-info">
                <h4>Selected Object Properties</h4>
                <div class="property-row">
                    <label>Type:</label> <span id="object-type" style="color:#f77f00; font-weight: bold;">None</span>
                </div>
                
                <hr>
                
                <h4>Material Properties</h4>
                <div class="property-row">
                    <label for="material-color">Color:</label> 
                    <input type="color" id="material-color" value="#5599ff" onchange="updateObjectColor(this.value)" disabled>
                </div>
                <div class="property-row">
                    <label for="material-wireframe">Wireframe:</label>
                    <input type="checkbox" id="material-wireframe" onchange="toggleWireframe(this.checked)" disabled>
                </div>

                <hr>

                <h4>Position</h4>
                <div class="property-row">
                    <label>X:</label> <input type="number" id="pos-x" step="0.1" class="property-input" onchange="updateObjectProperty('position.x', this.value)" disabled>
                </div>
                <div class="property-row">
                    <label>Y:</label> <input type="number" id="pos-y" step="0.1" class="property-input" onchange="updateObjectProperty('position.y', this.value)" disabled>
                </div>
                <div class="property-row">
                    <label>Z:</label> <input type="number" id="pos-z" step="0.1" class="property-input" onchange="updateObjectProperty('position.z', this.value)" disabled>
                </div>

                <h4>Rotation (Degrees)</h4>
                <div class="property-row">
                    <label>X:</label> <input type="number" id="rot-x" step="5" class="property-input" onchange="updateObjectRotation('rotation.x', this.value)" disabled>
                </div>
                <div class="property-row">
                    <label>Y:</label> <input type="number" id="rot-y" step="5" class="property-input" onchange="updateObjectRotation('rotation.y', this.value)" disabled>
                </div>
                <div class="property-row">
                    <label>Z:</label> <input type="number" id="rot-z" step="5" class="property-input" onchange="updateObjectRotation('rotation.z', this.value)" disabled>
                </div>

                <h4>Scale</h4>
                <div class="property-row">
                    <label>X:</label> <input type="number" id="scale-x" step="0.1" class="property-input" onchange="updateObjectScale('scale.x', this.value)" disabled>
                </div>
                <div class="property-row">
                    <label>Y:</label> <input type="number" id="scale-y" step="0.1" class="property-input" onchange="updateObjectScale('scale.y', this.value)" disabled>
                </div>
                <div class="property-row">
                    <label>Z:</label> <input type="number" id="scale-z" step="0.1" class="property-input" onchange="updateObjectScale('scale.z', this.value)" disabled>
                </div>
                
                <hr>
                
                <h4>Base Dimensions (Read-Only)</h4>
                <div class="property-row">
                    <label>Dimension 1:</label> <span id="dim-1" style="color:#f77f00;">—</span>
                </div>
                <div class="property-row">
                    <label>Dimension 2:</label> <span id="dim-2" style="color:#f77f00;">—</span>
                </div>
                <div class="property-row">
                    <label>Dimension 3:</label> <span id="dim-3" style="color:#f77f00;">—</span>
                </div>
            </div>

            <hr>
            
            <button onclick="deleteSelectedObject()">Delete Selected Object (Del)</button>

            <hr>

            <div id="scene-data-controls">
                <h4>Scene Persistence</h4>
                <button onclick="exportScene()">Export Scene (Save)</button>
                <button onclick="showImportModal()">Import Scene (Load)</button>
            </div>
        </div>
    </div>
    
    <!-- Custom Message Box -->
    <div id="message-box"></div>

    <!-- Custom Import Modal -->
    <div id="import-modal">
        <div id="import-content">
            <h3>Import Scene Data</h3>
            <p style="color: #aaa;">Paste the exported JSON data below to load a saved scene.</p>
            <textarea id="import-textarea" placeholder="Paste JSON data here..."></textarea>
            <div style="display: flex; justify-content: space-between;">
                <button style="background-color: #f77f00; border-color: #f77f00;" onclick="confirmImport()">Load Scene</button>
                <button style="background-color: #555; border-color: #555;" onclick="closeImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

    <script>
        // --- Core Setup Variables ---
        let scene, camera, renderer, controls, raycaster, mouse;
        let selectableObjects = [];
        let selectedObject = null;
        const container = document.getElementById('container');
        let transformControls;

        // Initial material properties (color set below to match UI)
        const BASE_COLOR = 0x5599ff;
        const HIGHLIGHT_COLOR = 0xff0000;
        // BASE_MATERIAL is now created inside init to ensure color is set correctly
        let BASE_MATERIAL;

        // Helper function for converting degrees to radians
        const degToRad = (degrees) => degrees * (Math.PI / 180);
        const radToDeg = (radians) => radians * (180 / Math.PI);

        // --- Custom Message Handling (Replaces alert/prompt) ---
        const messageBox = document.getElementById('message-box');
        const importModal = document.getElementById('import-modal');
        const importTextarea = document.getElementById('import-textarea');
        let messageTimeout;

        /**
         * Displays a non-blocking message or error to the user.
         */
        function showMessage(message, isError = false) {
            clearTimeout(messageTimeout);
            messageBox.textContent = message;
            messageBox.className = 'visible';
            if (isError) {
                messageBox.classList.add('error');
            } else {
                messageBox.classList.remove('error');
            }
            
            messageTimeout = setTimeout(() => {
                messageBox.classList.remove('visible');
            }, 3000); // Message disappears after 3 seconds
        }

        /**
         * Shows the custom import modal.
         */
        function showImportModal() {
            importModal.classList.add('visible');
            importTextarea.value = '';
            importTextarea.focus();
        }

        /**
         * Closes the custom import modal.
         */
        function closeImportModal() {
            importModal.classList.remove('visible');
        }

        /**
         * Confirms import and calls the import logic.
         */
        function confirmImport() {
            const jsonInput = importTextarea.value;
            closeImportModal();
            if (jsonInput) {
                try {
                    importScene(jsonInput);
                } catch (e) {
                    showMessage("Error importing scene: Invalid JSON format or data structure.", true);
                    console.error("Import Error:", e);
                }
            } else {
                showMessage("Import cancelled or no data provided.", true);
            }
        }


        // --- Initialization ---
        init();
        animate();

        function init() {
            // Define base material here after base color is set
            BASE_MATERIAL = new THREE.MeshPhongMaterial({ color: BASE_COLOR, specular: 0x111111, shininess: 30 });
            
            // 1. Scene Setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1e1e1e); // Darker background
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);

            // Lighting
            scene.add(new THREE.AmbientLight(0x404040));
            const light = new THREE.DirectionalLight(0xffffff, 1.0);
            light.position.set(20, 30, 10);
            scene.add(light);

            // OrbitControls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true; 

            // Helpers
            scene.add(new THREE.GridHelper(20, 20, 0x444444, 0x444444));
            scene.add(new THREE.AxesHelper(5));

            // Raycasting Setup
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // TransformControls setup
            transformControls = new THREE.TransformControls(camera, renderer.domElement);
            transformControls.addEventListener('dragging-changed', function (event) {
                controls.enabled = !event.value; // Disable orbit when dragging
                if (!event.value) { // Update sidebar when drag ends
                    updateSidebar();
                }
            });
            transformControls.addEventListener('change', function() {
                // Continuously update position/rotation/scale fields in the sidebar while transforming
                if (transformControls.dragging) {
                    updateSidebar(false); // Update without refreshing all dimensions
                }
            });
            
            setTransformMode("translate"); // Initialize mode buttons
            scene.add(transformControls);
            
            // Allow keyboard shortcuts for TransformControls: T=Translate, R=Rotate, S=Scale
            window.addEventListener('keydown', function (event) {
                switch (event.key.toLowerCase()) {
                    case 't': setTransformMode("translate"); break;
                    case 'r': setTransformMode("rotate"); break;
                    case 's': setTransformMode("scale"); break;
                    case 'delete': 
                    case 'backspace':
                        if (selectedObject) deleteSelectedObject();
                        break;
                }
            });

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            renderer.domElement.addEventListener('click', onMouseClick, false);

            // Start scene with an initial object
            addShape('box', new THREE.Vector3(2, 0.5, 2));
        }

        function onWindowResize() {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // --- Transform Controls Mode ---

        function setTransformMode(mode) {
            transformControls.setMode(mode);
            // Update active button state
            document.getElementById('mode-translate').classList.remove('active');
            document.getElementById('mode-rotate').classList.remove('active');
            document.getElementById('mode-scale').classList.remove('active');
            document.getElementById(`mode-${mode}`).classList.add('active');
        }

        // --- Object Management ---

        function createMaterial() {
            // Create a new material instance based on the BASE_MATERIAL
            const newMaterial = BASE_MATERIAL.clone();
            // Set a random starting color for new objects
            newMaterial.color.setHex(Math.random() * 0xffffff);
            return newMaterial;
        }

        function addShape(type, position) {
            let geometry;
            let mesh;
            let randomSize = Math.random() * 1.5 + 0.5;

            switch (type) {
                case 'box':
                    geometry = new THREE.BoxGeometry(randomSize, randomSize, randomSize);
                    mesh = new THREE.Mesh(geometry, createMaterial());
                    mesh.userData.shapeType = 'Box';
                    mesh.userData.dimensions = { width: randomSize, height: randomSize, depth: randomSize };
                    break;
                case 'sphere':
                    geometry = new THREE.SphereGeometry(randomSize / 2, 32, 32);
                    mesh = new THREE.Mesh(geometry, createMaterial());
                    mesh.userData.shapeType = 'Sphere';
                    mesh.userData.dimensions = { radius: randomSize / 2 };
                    break;
                case 'cylinder':
                    let radiusTop = randomSize / 2;
                    let radiusBottom = radiusTop * (Math.random() * 0.5 + 0.5);
                    let height = randomSize * 2;
                    geometry = new THREE.CylinderGeometry(radiusTop, radiusBottom, height, 32);
                    mesh = new THREE.Mesh(geometry, createMaterial());
                    mesh.userData.shapeType = 'Cylinder';
                    mesh.userData.dimensions = { radiusTop: radiusTop, radiusBottom: radiusBottom, height: height };
                    break;
                default:
                    return;
            }

            // Set position (on grid based on geometry center)
            if (position) {
                mesh.position.copy(position);
            } else {
                mesh.position.x = (Math.random() - 0.5) * 10;
                mesh.position.y = mesh.userData.shapeType === 'Box' ? randomSize / 2 : 
                                 mesh.userData.shapeType === 'Sphere' ? randomSize / 2 : mesh.userData.dimensions.height / 2;
                mesh.position.z = (Math.random() - 0.5) * 10;
            }

            mesh.uuid = THREE.MathUtils.generateUUID();
            mesh.userData.id = mesh.uuid;
            mesh.name = `${mesh.userData.shapeType}_${mesh.uuid.substring(0, 4)}`;

            scene.add(mesh);
            selectableObjects.push(mesh);
            selectObject(mesh);
        }
        
        function deleteSelectedObject() {
            if (!selectedObject) return;
            
            // Remove from scene and selectable list
            scene.remove(selectedObject);
            selectableObjects = selectableObjects.filter(obj => obj.uuid !== selectedObject.uuid);
            
            // Dispose of resources
            selectedObject.geometry.dispose();
            selectedObject.material.dispose();
            
            showMessage(`Deleted object: ${selectedObject.name}`);
            
            // Deselect
            selectObject(null);
        }

        // --- Selection & Highlight ---

        function onMouseClick(event) {
            if (transformControls.dragging) return;

            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ( ( event.clientX - rect.left ) / rect.width ) * 2 - 1;
            mouse.y = - ( ( event.clientY - rect.top ) / rect.height ) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Filter out TransformControls gizmos from raycasting
            const intersects = raycaster.intersectObjects(selectableObjects, false);

            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            } else {
                selectObject(null);
            }
        }

        function selectObject(object) {
            if (selectedObject && selectedObject !== object) {
                // Restore original color when deselecting
                if (selectedObject.userData.originalColor) {
                    selectedObject.material.color.set(selectedObject.userData.originalColor);
                } else {
                    selectedObject.material.color.set(BASE_COLOR);
                }
                transformControls.detach();
            }

            selectedObject = object;

            if (selectedObject) {
                // Save original color before highlighting
                selectedObject.userData.originalColor = selectedObject.material.color.clone();
                // Apply highlight color
                selectedObject.material.color.set(HIGHLIGHT_COLOR); 
                transformControls.attach(selectedObject);
            }

            updateSidebar();
        }

        // --- Sidebar/Property Display and Manipulation ---
        
        /**
         * Updates the material color of the selected object.
         */
        function updateObjectColor(hexColor) {
            if (!selectedObject) return;
            selectedObject.material.color.set(hexColor);
            selectedObject.userData.originalColor = selectedObject.material.color.clone(); // Update original color too
        }

        /**
         * Toggles the wireframe display of the selected object.
         */
        function toggleWireframe(checked) {
            if (!selectedObject) return;
            selectedObject.material.wireframe = checked;
        }

        // Position handler 
        function updateObjectProperty(propertyPath, value) {
            if (!selectedObject) return;
            const numericValue = parseFloat(value);
            if (isNaN(numericValue)) {
                showMessage("Invalid input for position.", true);
                updateSidebar(); // Revert input field
                return;
            }
            const parts = propertyPath.split('.');
            if (parts.length === 2) {
                if (selectedObject[parts[0]] && selectedObject[parts[0]][parts[1]] !== undefined) {
                    selectedObject[parts[0]][parts[1]] = numericValue;
                    updateSidebar();
                }
            }
        }
        
        // Rotation handler 
        function updateObjectRotation(propertyPath, value) {
            if (!selectedObject) return;
            const numericValue = parseFloat(value);
            if (isNaN(numericValue)) {
                 showMessage("Invalid input for rotation.", true);
                 updateSidebar(); // Revert input field
                 return;
            }
            
            const parts = propertyPath.split('.');
            if (parts.length === 2 && parts[0] === 'rotation') {
                // Three.js rotation is in Radians, but user input is in Degrees
                const radians = degToRad(numericValue);
                selectedObject.rotation[parts[1]] = radians;
                updateSidebar(); // Refresh the sidebar
            }
        }

        // Scale handler 
        function updateObjectScale(propertyPath, value) {
            if (!selectedObject) return;
            const numericValue = parseFloat(value);
            if (isNaN(numericValue) || numericValue <= 0) {
                showMessage("Scale value must be a positive number.", true);
                updateSidebar();
                return;
            }
            const parts = propertyPath.split('.');
            if (parts[0] === 'scale' && selectedObject.scale[parts[1]] !== undefined) {
                selectedObject.scale[parts[1]] = numericValue;
                updateSidebar();
            }
        }

        /**
         * Updates the sidebar with all properties.
         * @param {boolean} updateDimensions If true, updates all fields including read-only dimensions. Default is true.
         */
        function updateSidebar(updateDimensions = true) {
            // Get all property input elements and controls
            const inputs = {
                type: document.getElementById('object-type'),
                color: document.getElementById('material-color'),
                wireframe: document.getElementById('material-wireframe'),
                posX: document.getElementById('pos-x'),
                posY: document.getElementById('pos-y'),
                posZ: document.getElementById('pos-z'),
                rotX: document.getElementById('rot-x'),
                rotY: document.getElementById('rot-y'),
                rotZ: document.getElementById('rot-z'),
                scaleX: document.getElementById('scale-x'),
                scaleY: document.getElementById('scale-y'),
                scaleZ: document.getElementById('scale-z'),
                dim1: document.getElementById('dim-1'),
                dim2: document.getElementById('dim-2'),
                dim3: document.getElementById('dim-3'),
            };

            const allInputs = [inputs.color, inputs.wireframe, inputs.posX, inputs.posY, inputs.posZ, inputs.rotX, inputs.rotY, inputs.rotZ, inputs.scaleX, inputs.scaleY, inputs.scaleZ];
            
            if (selectedObject) {
                // Enable inputs
                allInputs.forEach(el => el.disabled = false);

                // Type
                inputs.type.textContent = selectedObject.userData.shapeType;
                
                // Material
                // Note: Get the *original* color for display, not the highlight color
                const displayColor = selectedObject.userData.originalColor || selectedObject.material.color; 
                inputs.color.value = '#' + displayColor.getHexString();
                inputs.wireframe.checked = selectedObject.material.wireframe;

                // Position
                const pos = selectedObject.position;
                inputs.posX.value = pos.x.toFixed(2);
                inputs.posY.value = pos.y.toFixed(2);
                inputs.posZ.value = pos.z.toFixed(2);
                
                // Rotation (Convert Radians to Degrees)
                const rot = selectedObject.rotation;
                inputs.rotX.value = radToDeg(rot.x).toFixed(1);
                inputs.rotY.value = radToDeg(rot.y).toFixed(1);
                inputs.rotZ.value = radToDeg(rot.z).toFixed(1);

                // Scale
                const scale = selectedObject.scale;
                inputs.scaleX.value = scale.x.toFixed(2);
                inputs.scaleY.value = scale.y.toFixed(2);
                inputs.scaleZ.value = scale.z.toFixed(2);

                // Dimensions (Read-Only) - Only update if explicitly requested
                if (updateDimensions) {
                    const dims = selectedObject.userData.dimensions;
                    inputs.dim1.textContent = dims.width ? `W: ${dims.width.toFixed(2)}` : dims.radius ? `R: ${dims.radius.toFixed(2)}` : `R Top: ${dims.radiusTop.toFixed(2)}`;
                    inputs.dim2.textContent = dims.height ? `H: ${dims.height.toFixed(2)}` : dims.radiusBottom ? `R Bot: ${dims.radiusBottom.toFixed(2)}` : '—';
                    inputs.dim3.textContent = dims.depth ? `D: ${dims.depth.toFixed(2)}` : dims.height ? `H: ${dims.height.toFixed(2)}` : '—';
                }

            } else {
                // Deselect state
                inputs.type.textContent = 'None';
                // Reset all input values and disable
                allInputs.filter(el => el && el.tagName === 'INPUT').forEach(el => {
                    el.value = (el.type === 'color' ? '#5599ff' : '—');
                    el.disabled = true;
                });
                 inputs.wireframe.checked = false;
                 inputs.wireframe.disabled = true;
                inputs.dim1.textContent = inputs.dim2.textContent = inputs.dim3.textContent = '—';
            }
        }

        // --- Scene Persistence (JSON) ---

        function exportScene() {
            const objectsData = [];
            selectableObjects.forEach(object => {
                objectsData.push({
                    uuid: object.uuid,
                    type: object.userData.shapeType,
                    position: object.position.toArray(),
                    rotation: object.rotation.toArray(),
                    scale: object.scale.toArray(),
                    dimensions: object.userData.dimensions,
                    // NEW: Material properties
                    color: '#' + (object.userData.originalColor || object.material.color).getHexString(),
                    wireframe: object.material.wireframe,
                });
            });

            const sceneData = {
                version: '1.2', // Version update due to new features (Color/Wireframe)
                objects: objectsData,
                metadata: {
                    camera: {
                        position: camera.position.toArray(),
                        target: controls.target.toArray()
                    }
                }
            };

            const jsonOutput = JSON.stringify(sceneData, null, 2);
            console.log("--- Scene JSON Export (v1.2) ---");
            console.log(jsonOutput);
            
            // Copy to clipboard
            navigator.clipboard.writeText(jsonOutput)
                .then(() => showMessage("Scene JSON data copied to clipboard and logged to console (F12)."))
                .catch(() => showMessage("Scene JSON data logged to console. Clipboard access failed.", true));
        }

        function importScene(jsonString) {
            const sceneData = JSON.parse(jsonString);

            if (!['1.0', '1.1', '1.2'].includes(sceneData.version)) {
                showMessage(`Unsupported scene version: ${sceneData.version}.`, true);
                return;
            }

            // 1. Clear existing scene objects 
            selectableObjects.forEach(object => {
                scene.remove(object);
                object.geometry.dispose();
                object.material.dispose(); 
            });
            selectableObjects = [];
            selectObject(null); 

            // 2. Recreate objects
            sceneData.objects.forEach(data => {
                let geometry;
                let mesh;
                
                // Create material based on saved data (or default if older version)
                const material = BASE_MATERIAL.clone();
                if (data.color) {
                    material.color.set(data.color);
                }
                if (data.wireframe !== undefined) {
                    material.wireframe = data.wireframe;
                }

                switch (data.type) {
                    case 'Box':
                        const boxDims = data.dimensions;
                        geometry = new THREE.BoxGeometry(boxDims.width, boxDims.height, boxDims.depth);
                        break;
                    case 'Sphere':
                        const sphereDims = data.dimensions;
                        geometry = new THREE.SphereGeometry(sphereDims.radius, 32, 32);
                        break;
                    case 'Cylinder':
                        const cylinderDims = data.dimensions;
                        geometry = new THREE.CylinderGeometry(cylinderDims.radiusTop, cylinderDims.radiusBottom, cylinderDims.height, 32);
                        break;
                    default:
                        console.warn(`Unknown object type during import: ${data.type}`);
                        return;
                }

                mesh = new THREE.Mesh(geometry, material);

                // Restore properties
                mesh.position.fromArray(data.position);
                if (data.rotation) {
                    mesh.rotation.fromArray(data.rotation);
                }
                mesh.scale.fromArray(data.scale);
                mesh.uuid = data.uuid;
                mesh.userData.shapeType = data.type;
                mesh.userData.dimensions = data.dimensions;
                // Store the original color on userData for correct highlighting/deselecting
                mesh.userData.originalColor = material.color.clone(); 
                mesh.name = `${data.type}_${mesh.uuid.substring(0, 4)}`;

                scene.add(mesh);
                selectableObjects.push(mesh);
            });

            // 3. Restore camera/controls
            if (sceneData.metadata && sceneData.metadata.camera) {
                camera.position.fromArray(sceneData.metadata.camera.position);
                controls.target.fromArray(sceneData.metadata.camera.target);
                controls.update();
            }

            showMessage(`Scene successfully imported with ${sceneData.objects.length} objects (v${sceneData.version})!`);
        }
    </script>
</body>
</html>